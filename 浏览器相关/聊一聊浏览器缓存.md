我们工作中经常会聊到项目的性能优化，在性能优化诸多手段之中，合理使用浏览器缓存是一个重要手段，有助于我们节省请求资源，提升用户体验。

浏览器缓存分为**强缓存**和**协商缓存**，强缓存命中时，优先使用强缓存。强缓存失效后则进入协商缓存，如果协商缓存仍未命中，则发送请求。下面分别来聊一聊👇。

## 强缓存

强缓存有两个关键字段，「**Expires**」和「**Cache-Control**」。

当我们产生请求时，首先检查强缓存，这个阶段无需发送HTTP请求。通过查找不同的字段来进行命中，HTTP1.0版本，使用的是**Expires**，HTTP1.1使用的是**Cache-Control**。

#### Expires

expires即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需发送请求。比如下面这个：

<code>Expires:Mon, 29 Jun 2020 11:10:23 GMT</code>

表示该资源在2020年 7月29日11:10:23过期，过期后就会重新向服务器发起请求。

但是这种方式有个问题：「**服务器的时间和浏览器的时间可能并不一致**」，因此，HTTP1.1提出了一个新字段来代替它。

#### Cache-Control

HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。

<code>Cache-Control:max-age=6000</code>

上面代表该资源返回后6000秒，可以直接使用缓存。

⚠️注意点：

- 当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
- 当缓存资源失效，也就是没有命中强缓存，接下来就进入协商缓存👇。



## 协商缓存

强缓存失效后，浏览器在请求头中携带响应的`缓存Tag`来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。

缓存分为两种，**「Last-Modified」** 和 **「ETag」**。两者各有优势，并不存在谁对谁有`绝对的优势`，与上面所讲的强缓存两个Tag所不同。

#### Last-Modified

这个字段表示的是**「最后修改时间」**。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，**「如果再次请求」**，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接使用缓存。

#### ETag

ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。

浏览器接受到ETag值，会在下次请求的时候，将这个值作为**「If-None-Match」**这个字段的内容，发给服务器。

服务器接收到**「If-None-Match」**后，会跟服务器上该资源的**「ETag」**进行比对👇

- 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存。
- 如果不一样的话，说明内容更新，返回新的资源，跟常规的HTTP请求响应的流程一样。

⚠️两者对比：

- 性能上，`Last-Modified`优于`ETag`，`Last-Modified`记录的是时间点，而`Etag`需要根据文件的MD5算法生成对应的hash值。
- 精度上，`ETag`优于`Last-Modified`。`ETag`按照内容给资源带上标识，能准确感知资源变化，`Last-Modified`在某些场景并不能准确感知变化，比如👇
  1. 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  2. Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

**如果两种方式都支持的话，服务器会优先考虑`ETag`**



## 缓存位置

缓存位置可以分为四种，优先级从高到低分别是：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

#### Service Worker

这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：`离线缓存`、`消息推送`和`网络代理`，其中`离线缓存`就是**「Service Worker Cache」**。

#### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

#### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。

(内容使用率高的话，文件优先进入磁盘，比较大的JS，CSS文件会直接放入磁盘，反之放入内存。)

#### Push Cache

推送缓存，它是`HTTP/2`的内容。



## 总结

1. 先检查`Cache-Control`， 尝鲜，看强缓存是否可用。
2. 如果可用的话，直接使用。
3. 否则进入协商缓存，发送HTTP请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新。
4. 资源更新，返回资源和200状态码。
5. 否则，返回304，直接告诉浏览器直接从缓存中去资源。